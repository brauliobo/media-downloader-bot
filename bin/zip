#!/usr/bin/env ruby

STDOUT.sync = true
ENV['PRINT_CMD'] = '1'
ENV['SKIP_META'] = '1'
ENV['DB'] = '1' if ENV['SESSION_UID']
ENV['PUPPETEER_HEADLESS'] ||= '0'

Dir.chdir File.expand_path "#{File.realpath __dir__}/.." do
  require_relative '../lib/bot/base'
  require_relative '../lib/worker'  # Requires active_support/all, processors, zipper, tagger, status, etc.
  require_relative '../lib/bot/worker/service'
end

opts  = SymMash.new metadata: {}
lopts = []
while ARGV[-1] and !File.exist?(ARGV[-1]) and ARGV[-1] !~ URI::regexp
  opt = ARGV.pop
  lopts.push opt
  Processors::Base.add_opt opts, opt
end

Zipper.size_mb_limit = ENV['SIZE_MB_LIMIT']&.to_i

bot = Bot::Mock.new
Worker.worker = Bot::Worker::Service.new(bot)
st  = Bot::Status.new do |line|
  puts line
end
stl = Bot::Status::Line.new '', status: st

raise "No files found" if ARGV.blank?
path = if ARGV.size > 1 then ARGV else ARGV.first&.split "\n" end
path.peach do |u|
  base_dir = u =~ URI::regexp ? Dir.pwd : File.dirname(u)
  dir      = "#{base_dir}/converted"
  FileUtils.mkdir_p dir

  if u =~ URI::regexp
    klass = Processors::Url
  elsif File.extname(u).downcase.in?(['.pdf', '.epub'])
    # Direct PDF/EPUB to audiobook (OCR/parse + TTS)
    require_relative '../lib/audiobook'

    fmt_spec  = Zipper.choose_format Zipper::Types.audio, opts, nil
    base_name = File.basename(u, File.extname(u))
    audio_out = "#{dir}/#{base_name}.#{fmt_spec.ext}"
    result = Audiobook.generate u, audio_out, stl: stl, opts: opts

    puts "YAML saved to #{result.yaml}" if result.respond_to?(:yaml) && result.yaml
    puts "Audiobook saved to #{result.audio}" if result.respond_to?(:audio) && result.audio
    next
  else
    klass = Processors::Base
  end

  if klass == Processors::Url
    line = "#{u} #{lopts.join ' '}"
    prc  = klass.new(dir:, line:, st:, stline: stl)
    prc.download.peach do |i|
      prc.download_one i
      prc.handle_input i
      prc.cleanup
    end
  else
    prc = klass.new(dir:, st:)
    i   = prc.input_from_file u, opts
    prc.handle_input i

    Tagger.copy u, i.fn_out if i.type && i.fn_out
    prc.cleanup
  end
end

